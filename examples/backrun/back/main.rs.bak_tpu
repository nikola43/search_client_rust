use std::{
    panic,
    panic::PanicInfo,
    process,
    str::FromStr,
    sync::{
        atomic::{AtomicBool, Ordering},
        Arc,
    },
    time::Duration,
};

use env_logger::TimestampPrecision;
use jito_protos::{
    auth::auth_service_client::AuthServiceClient,
    searcher::searcher_service_client::SearcherServiceClient,
};
use jito_searcher_client::{
    client_interceptor::ClientInterceptor, cluster_data_impl::ClusterDataImpl, grpc_connect,
    SearcherClient, SearcherClientResult,
};

use solana_client::{
    nonblocking::{rpc_client::RpcClient, tpu_client::TpuClient},
    tpu_client::TpuClientConfig,
};

use solana_sdk::{
    commitment_config::CommitmentConfig,
    pubkey::Pubkey,
    signature::{read_keypair_file, Keypair, Signer},
    system_instruction::{self, transfer},
    transaction::Transaction,
};

use jito_protos::bundle::bundle_result::Result;
use tonic::{codegen::InterceptedService, transport::Channel};

#[tokio::main]
async fn main() {
    env_logger::builder()
        .format_timestamp(Some(TimestampPrecision::Micros))
        .init();

    let lamports = 1000;
    let rpc_url = "https://api.mainnet-beta.solana.com";
    let ws_url = "wss://api.mainnet-beta.solana.com";
    let block_engine_url = "https://amsterdam.mainnet.block-engine.jito.wtf";
    let auth_keypair_path = "./jito-keypair.json";
    let auth_keypair =
        Arc::new(read_keypair_file(auth_keypair_path).expect("reads keypair at path"));
    let payer = "./my-keypair.json";
    let payer_keypair = read_keypair_file(&payer).expect("reads keypair at path");
    let exit = Arc::new(AtomicBool::new(false));
    let recipient_pubkey =
        Pubkey::from_str("GKxpQ3ZSMNSbCDs1RrqhxuTTUfn8xx6faDzTss38mkw3").unwrap();
    let lamports_to_send = 1_000; // 1 SOL

    let rpc_client =
        RpcClient::new_with_commitment(rpc_url.to_string(), CommitmentConfig::confirmed());

    // build + sign the transactions
    let blockhash = rpc_client
        .get_latest_blockhash()
        .await
        .expect("get blockhash");

    let transfer_instruction = system_instruction::transfer(
        &payer_keypair.pubkey(), // From (payer)
        &recipient_pubkey,       // To (recipient)
        lamports_to_send,        // Amount
    );

    let tip_account = Pubkey::from_str("HFqU5x63VTqvQss8hp11i4wVV8bD44PvwucfZ2bU7gRe").unwrap();

    let jito_tip_instruction = transfer(&payer_keypair.pubkey(), &tip_account, lamports);

    let mut transaction = Transaction::new_with_payer(
        &[transfer_instruction, jito_tip_instruction],
        Some(&payer_keypair.pubkey()),
    );
    transaction.sign(&[&payer_keypair], blockhash);
    //let wire_transaction = bincode::serialize(&transaction).unwrap();
    //let transaction_signature = transaction.signatures[0];

    //let txs: &Vec<Signature> = &vec![transaction.signatures[0]];
    let wire_transaction = bincode::serialize(&transaction).unwrap();
    let singature = transaction.signatures[0];
    println!("singature: {:?}", singature);

    let mut tx_accepted = false;
    let auth_keypair =
        Arc::new(read_keypair_file(auth_keypair_path).expect("reads keypair at path"));
    let exit = Arc::new(AtomicBool::new(false));

    let searcher_client_service =
        get_searcher_client(&auth_keypair, &exit, block_engine_url, rpc_url)
            .await
            .unwrap();
    let (mut searcher_client, cluster_data) = searcher_client_service;

    let config = TpuClientConfig::default();
    let rpc_client = Arc::new(solana_client::nonblocking::rpc_client::RpcClient::new(
        rpc_url.to_string(),
    ));

    let tpu_client = TpuClient::new(rpc_client, ws_url, config).await.unwrap();

    let r = searcher_client
        .send_transaction(&tpu_client, wire_transaction)
        .await;
    print!("r: {:?}", r);

    // let mut receiver_result = searcher_client
    //     .subscribe_bundle_results(10000)
    //     .await
    //     .unwrap();
    // let bundle_result = receiver_result.recv().await.unwrap();
    // let result = bundle_result.result.unwrap();

    // println!("result: {:?}", result);
}

async fn get_searcher_client(
    auth_keypair: &Arc<Keypair>,
    exit: &Arc<AtomicBool>,
    block_engine_url: &str,
    rpc_pubsub_addr: &str,
) -> SearcherClientResult<(
    SearcherClient<ClusterDataImpl, InterceptedService<Channel, ClientInterceptor>>,
    ClusterDataImpl,
)> {
    let auth_channel = grpc_connect(block_engine_url).await?;
    let client_interceptor =
        ClientInterceptor::new(AuthServiceClient::new(auth_channel), auth_keypair).await?;

    let searcher_channel = grpc_connect(block_engine_url).await?;
    let searcher_service_client =
        SearcherServiceClient::with_interceptor(searcher_channel, client_interceptor);

    let cluster_data_impl = ClusterDataImpl::new(
        rpc_pubsub_addr.to_string(),
        searcher_service_client.clone(),
        exit.clone(),
    )
    .await;

    Ok((
        SearcherClient::new(
            cluster_data_impl.clone(),
            searcher_service_client,
            exit.clone(),
        ),
        cluster_data_impl,
    ))
}
